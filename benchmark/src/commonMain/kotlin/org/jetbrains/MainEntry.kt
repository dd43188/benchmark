package org.jetbrains

import org.jetbrains.ring.*
import kotlin.time.measureTime

internal class TaskWrapper(
    val task: () -> Unit
)

expect fun kLog(log:String)

internal object Launcher {
    val tasks = mutableMapOf(
        "AbstractMethod.sortStrings" to TaskWrapper { AbstractMethodBenchmark().sortStrings() },
        "ClassArray.copy" to TaskWrapper { ClassArrayBenchmark().copy() },
        "ClassArray.filter" to TaskWrapper { ClassArrayBenchmark().filter() },
        "ClassArray.countFiltered" to TaskWrapper { ClassArrayBenchmark().countFiltered() },
        "ClassBaseline.consume" to TaskWrapper { ClassBaselineBenchmark().consume() },
        "ClassBaseline.consumeField" to TaskWrapper { ClassBaselineBenchmark().consumeField() },
        "ClassBaseline.allocateListAndFill" to TaskWrapper { ClassBaselineBenchmark().allocateListAndFill() },
        "ClassList.copy" to TaskWrapper { ClassListBenchmark().copy() },
        "ClassList.mapWithLambda" to TaskWrapper { ClassListBenchmark().mapWithLambda() },
        "ClassList.filter" to TaskWrapper { ClassListBenchmark().filter() },
        "ClassList.reduce" to TaskWrapper { ClassListBenchmark().reduce() },
        "ClassStream.copy" to TaskWrapper { ClassStreamBenchmark().copy() },
        "ClassStream.filter" to TaskWrapper { ClassStreamBenchmark().filter() },
        "ClassStream.reduce" to TaskWrapper { ClassStreamBenchmark().reduce() },
        "Elvis.testElvis" to TaskWrapper { ElvisBenchmark().testElvis() },
        "Euler.problem1bySequence" to TaskWrapper { EulerBenchmark().problem1bySequence() },
        "Euler.problem9" to TaskWrapper { EulerBenchmark().problem9() },
        "Euler.problem14" to TaskWrapper { EulerBenchmark().problem14() },
        "Fibonacci.calcClassic" to TaskWrapper { FibonacciBenchmark().calcClassic() },
        "Fibonacci.calc" to TaskWrapper { FibonacciBenchmark().calc() },
        "ForLoops.arrayLoop" to TaskWrapper { ForLoopsBenchmark().arrayLoop() },
        "ForLoops.arrayIndicesLoop" to TaskWrapper { ForLoopsBenchmark().arrayIndicesLoop() },
        "Inline.calculateInline" to TaskWrapper { InlineBenchmark().calculateInline() },
        "Lambda.noncapturingLambda" to TaskWrapper { LambdaBenchmark().noncapturingLambda() },
        "Lambda.capturingLambda" to TaskWrapper { LambdaBenchmark().capturingLambda() },
        "Lambda.methodReference" to TaskWrapper { LambdaBenchmark().methodReference() },
        "Loop.arrayLoop" to TaskWrapper { LoopBenchmark().arrayLoop() },
        "Loop.rangeLoop" to TaskWrapper { LoopBenchmark().rangeLoop() },
        "Loop.arrayWhileLoop" to TaskWrapper { LoopBenchmark().arrayWhileLoop() },
        "Loop.arrayForeachLoop" to TaskWrapper { LoopBenchmark().arrayForeachLoop() },
        "Loop.arrayListForeachLoop" to TaskWrapper { LoopBenchmark().arrayListForeachLoop() },
        "MatrixMap.add" to TaskWrapper { MatrixMapBenchmark().add() },
        "PrimeList.calcDirect" to TaskWrapper { PrimeListBenchmark().calcDirect() },
        "PrimeList.calcEratosthenes" to TaskWrapper { PrimeListBenchmark().calcEratosthenes() },
        "Singleton.access" to TaskWrapper { SingletonBenchmark().access() },
        "String.stringConcat" to TaskWrapper { StringBenchmark().stringConcat() },
        "String.stringBuilderConcat" to TaskWrapper { StringBenchmark().stringBuilderConcat() },
        "String.stringBuilderConcatNullable" to TaskWrapper { StringBenchmark().stringBuilderConcatNullable() },
        "String.summarizeSplittedCsv" to TaskWrapper { StringBenchmark().summarizeSplittedCsv() },
        "Switch.testStringsSwitch" to TaskWrapper { SwitchBenchmark().testStringsSwitch() },
        "Switch.testEnumsSwitch" to TaskWrapper { SwitchBenchmark().testEnumsSwitch() },
        "Switch.testSealedWhenSwitch" to TaskWrapper { SwitchBenchmark().testSealedWhenSwitch() },
        "WithIndicies.withIndicies" to TaskWrapper { WithIndiciesBenchmark().withIndicies() },
        "Calls.finalMethod" to TaskWrapper { CallsBenchmark().finalMethodCall() },
        "Calls.openMethodMonomorphic" to TaskWrapper { CallsBenchmark().classOpenMethodCall_MonomorphicCallsite() },
        "Calls.interfaceMethodMonomorphic" to TaskWrapper { CallsBenchmark().interfaceMethodCall_MonomorphicCallsite() },
        "Calls.returnBoxUnboxFolding" to TaskWrapper { CallsBenchmark().returnBoxUnboxFolding() },
        "Calls.parameterBoxUnboxFolding" to TaskWrapper { CallsBenchmark().parameterBoxUnboxFolding() },
        "CoordinatesSolver.solve" to TaskWrapper { CoordinatesSolverBenchmark().solve() },
        "Casts.classCast" to TaskWrapper { CastsBenchmark().classCast() },
        "Casts.interfaceCast" to TaskWrapper { CastsBenchmark().interfaceCast() },
        "LinkedListWithAtomicsBenchmark" to TaskWrapper { LinkedListWithAtomicsBenchmark().ensureNext() },
        "Inheritance.baseCalls" to TaskWrapper { InheritanceBenchmark().baseCalls() },
        "ChainableBenchmark.testChainable" to TaskWrapper { ChainableBenchmark().testChainable() },
        "BunnymarkBenchmark.testBunnymark" to TaskWrapper { BunnymarkBenchmark().testBunnymark() },
        "ArrayCopyBenchmark.copyInSameArray" to TaskWrapper { ArrayCopyBenchmark().copyInSameArray() }
    )

    val extendedBenchmarksSet = mutableMapOf(
        "AbstractMethod.sortStringsWithComparator" to TaskWrapper { AbstractMethodBenchmark().sortStringsWithComparator() },
        "AllocationBenchmark.allocateObjects" to TaskWrapper{ AllocationBenchmark().allocateObjects() },
        "ClassArray.copyManual" to TaskWrapper{ ClassArrayBenchmark().copyManual() },
        "ClassArray.filterAndCount" to TaskWrapper{ ClassArrayBenchmark().filterAndCount() },
        "ClassArray.filterAndMap" to TaskWrapper{ ClassArrayBenchmark().filterAndMap() },
        "ClassArray.filterAndMapManual" to TaskWrapper{ ClassArrayBenchmark().filterAndMapManual() },
        "ClassArray.filterManual" to TaskWrapper{ ClassArrayBenchmark().filterManual() },
        "ClassArray.countFilteredManual" to TaskWrapper{ ClassArrayBenchmark().countFilteredManual() },
        "ClassArray.countFilteredLocal" to TaskWrapper{ ClassArrayBenchmark().countFilteredLocal() },
        "ClassBaseline.allocateList" to TaskWrapper{ ClassBaselineBenchmark().allocateList() },
        "ClassBaseline.allocateArray" to TaskWrapper{ ClassBaselineBenchmark().allocateArray() },
        "ClassBaseline.allocateListAndWrite" to TaskWrapper{ ClassBaselineBenchmark().allocateListAndWrite() },
        "ClassBaseline.allocateArrayAndFill" to TaskWrapper{ ClassBaselineBenchmark().allocateArrayAndFill() },
        "ClassList.copyManual" to TaskWrapper{ ClassListBenchmark().copyManual() },
        "ClassList.filterAndCount" to TaskWrapper{ ClassListBenchmark().filterAndCount() },
        "ClassList.filterAndCountWithLambda" to TaskWrapper{ ClassListBenchmark().filterAndCountWithLambda() },
        "ClassList.filterWithLambda" to TaskWrapper{ ClassListBenchmark().filterWithLambda() },
        "ClassList.countWithLambda" to TaskWrapper{ ClassListBenchmark().countWithLambda() },
        "ClassList.filterAndMapWithLambda" to TaskWrapper{ ClassListBenchmark().filterAndMapWithLambda() },
        "ClassList.filterAndMapWithLambdaAsSequence" to TaskWrapper{ ClassListBenchmark().filterAndMapWithLambdaAsSequence() },
        "ClassList.filterAndMap" to TaskWrapper{ ClassListBenchmark().filterAndMap() },
        "ClassList.filterAndMapManual" to TaskWrapper{ ClassListBenchmark().filterAndMapManual() },
        "ClassList.filterManual" to TaskWrapper{ ClassListBenchmark().filterManual() },
        "ClassList.countFilteredManual" to TaskWrapper{ ClassListBenchmark().countFilteredManual() },
        "ClassList.countFiltered" to TaskWrapper{ ClassListBenchmark().countFiltered() },
        "ClassStream.copyManual" to TaskWrapper{ ClassStreamBenchmark().copyManual() },
        "ClassStream.filterAndCount" to TaskWrapper{ ClassStreamBenchmark().filterAndCount() },
        "ClassStream.filterAndMap" to TaskWrapper{ ClassStreamBenchmark().filterAndMap() },
        "ClassStream.filterAndMapManual" to TaskWrapper{ ClassStreamBenchmark().filterAndMapManual() },
        "ClassStream.filterManual" to TaskWrapper{ ClassStreamBenchmark().filterManual() },
        "ClassStream.countFilteredManual" to TaskWrapper{ ClassStreamBenchmark().countFilteredManual() },
        "ClassStream.countFiltered" to TaskWrapper{ ClassStreamBenchmark().countFiltered() },
        "CompanionObject.invokeRegularFunction" to TaskWrapper{ CompanionObjectBenchmark().invokeRegularFunction() },
        "DefaultArgument.testOneOfTwo" to TaskWrapper{ DefaultArgumentBenchmark().testOneOfTwo() },
        "DefaultArgument.testTwoOfTwo" to TaskWrapper{ DefaultArgumentBenchmark().testTwoOfTwo() },
        "DefaultArgument.testOneOfFour" to TaskWrapper{ DefaultArgumentBenchmark().testOneOfFour() },
        "DefaultArgument.testFourOfFour" to TaskWrapper{ DefaultArgumentBenchmark().testFourOfFour() },
        "DefaultArgument.testOneOfEight" to TaskWrapper{ DefaultArgumentBenchmark().testOneOfEight() },
        "DefaultArgument.testEightOfEight" to TaskWrapper{ DefaultArgumentBenchmark().testEightOfEight() },
        "Elvis.testCompositeElvis" to TaskWrapper{ ElvisBenchmark().testCompositeElvis() },
        "Euler.problem1" to TaskWrapper { EulerBenchmark().problem1() },
        "Euler.problem2" to TaskWrapper { EulerBenchmark().problem2() },
//        "Euler.problem4" to TaskWrapper { EulerBenchmark().problem4() }, 这个非常耗时
        "Euler.problem8" to TaskWrapper { EulerBenchmark().problem8() },
        "Euler.problem14full" to TaskWrapper{ EulerBenchmark().problem14full() },
        "Fibonacci.calcWithProgression" to TaskWrapper{ FibonacciBenchmark().calcWithProgression() },
        "Fibonacci.calcSquare" to TaskWrapper{ FibonacciBenchmark().calcSquare() },
        "ForLoops.intArrayLoop" to TaskWrapper{ ForLoopsBenchmark().intArrayLoop() },
        "ForLoops.floatArrayLoop" to TaskWrapper{ ForLoopsBenchmark().floatArrayLoop() },
        "ForLoops.charArrayLoop" to TaskWrapper{ ForLoopsBenchmark().charArrayLoop() },
        "ForLoops.stringLoop" to TaskWrapper{ ForLoopsBenchmark().stringLoop() },
        "ForLoops.stringArrayLoop" to TaskWrapper{ ForLoopsBenchmark().stringArrayLoop() },
        "ForLoops.uIntArrayLoop" to TaskWrapper{ ForLoopsBenchmark().uIntArrayLoop() },
        "ForLoops.uShortArrayLoop" to TaskWrapper{ ForLoopsBenchmark().uShortArrayLoop() },
        "ForLoops.uLongArrayLoop" to TaskWrapper{ ForLoopsBenchmark().uLongArrayLoop() },
        "ForLoops.intArrayIndicesLoop" to TaskWrapper{ ForLoopsBenchmark().intArrayIndicesLoop() },
        "ForLoops.floatArrayIndicesLoop" to TaskWrapper{ ForLoopsBenchmark().floatArrayIndicesLoop() },
        "ForLoops.charArrayIndicesLoop" to TaskWrapper{ ForLoopsBenchmark().charArrayIndicesLoop() },
        "ForLoops.stringIndicesLoop" to TaskWrapper{ ForLoopsBenchmark().stringIndicesLoop() },
        "ForLoops.uIntArrayIndicesLoop" to TaskWrapper{ ForLoopsBenchmark().uIntArrayIndicesLoop() },
        "ForLoops.uShortArrayIndicesLoop" to TaskWrapper{ ForLoopsBenchmark().uShortArrayIndicesLoop() },
        "ForLoops.uLongArrayIndicesLoop" to TaskWrapper{ ForLoopsBenchmark().uLongArrayIndicesLoop() },
        "Inline.calculate" to TaskWrapper { InlineBenchmark().calculate() },
        "Inline.calculateGeneric" to TaskWrapper { InlineBenchmark().calculateGeneric() },
        "Inline.calculateGenericInline" to TaskWrapper { InlineBenchmark().calculateGenericInline() },
        "IntArray.copy" to TaskWrapper { IntArrayBenchmark().copy() },
        "IntArray.copyManual" to TaskWrapper { IntArrayBenchmark().copyManual() },
        "IntArray.filterAndCount" to TaskWrapper { IntArrayBenchmark().filterAndCount() },
        "IntArray.filterSomeAndCount" to TaskWrapper { IntArrayBenchmark().filterSomeAndCount() },
        "IntArray.filterAndMap" to TaskWrapper { IntArrayBenchmark().filterAndMap() },
        "IntArray.filterAndMapManual" to TaskWrapper { IntArrayBenchmark().filterAndMapManual() },
        "IntArray.filter" to TaskWrapper { IntArrayBenchmark().filter() },
        "IntArray.filterSome" to TaskWrapper { IntArrayBenchmark().filterSome() },
        "IntArray.filterPrime" to TaskWrapper { IntArrayBenchmark().filterPrime() },
        "IntArray.filterManual" to TaskWrapper { IntArrayBenchmark().filterManual() },
        "IntArray.filterSomeManual" to TaskWrapper { IntArrayBenchmark().filterSomeManual() },
        "IntArray.countFilteredManual" to TaskWrapper { IntArrayBenchmark().countFilteredManual() },
        "IntArray.countFilteredSomeManual" to TaskWrapper { IntArrayBenchmark().countFilteredSomeManual() },
        "IntArray.countFilteredPrimeManual" to TaskWrapper { IntArrayBenchmark().countFilteredPrimeManual() },
        "IntArray.countFiltered" to TaskWrapper { IntArrayBenchmark().countFiltered() },
        "IntArray.countFilteredSome" to TaskWrapper { IntArrayBenchmark().countFilteredSome() },
        "IntArray.countFilteredPrime" to TaskWrapper { IntArrayBenchmark().countFilteredPrime() },
        "IntArray.countFilteredLocal" to TaskWrapper { IntArrayBenchmark().countFilteredLocal() },
        "IntArray.countFilteredSomeLocal" to TaskWrapper { IntArrayBenchmark().countFilteredSomeLocal() },
        "IntBaseline.consume" to TaskWrapper { IntBaselineBenchmark().consume() },
        "IntBaseline.allocateList" to TaskWrapper { IntBaselineBenchmark().allocateList() },
        "IntBaseline.allocateArray" to TaskWrapper { IntBaselineBenchmark().allocateArray() },
        "IntBaseline.allocateListAndFill" to TaskWrapper { IntBaselineBenchmark().allocateListAndFill() },
        "IntBaseline.allocateArrayAndFill" to TaskWrapper { IntBaselineBenchmark().allocateArrayAndFill() },
        "IntList.copy" to TaskWrapper { IntListBenchmark().copy() },
        "IntList.copyManual" to TaskWrapper { IntListBenchmark().copyManual() },
        "IntList.filterAndCount" to TaskWrapper { IntListBenchmark().filterAndCount() },
        "IntList.filterAndMap" to TaskWrapper{ IntListBenchmark().filterAndMap() },
        "IntList.filterAndMapManual" to TaskWrapper{ IntListBenchmark().filterAndMapManual() },
        "IntList.filter" to TaskWrapper { IntListBenchmark().filter() },
        "IntList.filterManual" to TaskWrapper{ IntListBenchmark().filterManual() },
        "IntList.countFilteredManual" to TaskWrapper{ IntListBenchmark().countFilteredManual() },
        "IntList.countFiltered" to TaskWrapper{ IntListBenchmark().countFiltered() },
        "IntList.countFilteredLocal" to TaskWrapper{ IntListBenchmark().countFilteredLocal() },
        "IntList.reduce" to TaskWrapper { IntListBenchmark().reduce() },
        "IntStream.copy" to TaskWrapper { IntStreamBenchmark().copy() },
        "IntStream.copyManual" to TaskWrapper{ IntStreamBenchmark().copyManual() },
        "IntStream.filterAndCount" to TaskWrapper{ IntStreamBenchmark().filterAndCount() },
        "IntStream.filterAndMap" to TaskWrapper{ IntStreamBenchmark().filterAndMap() },
        "IntStream.filterAndMapManual" to TaskWrapper{ IntStreamBenchmark().filterAndMapManual() },
        "IntStream.filter" to TaskWrapper { IntStreamBenchmark().filter() },
        "IntStream.filterManual" to TaskWrapper{ IntStreamBenchmark().filterManual() },
        "IntStream.countFilteredManual" to TaskWrapper{ IntStreamBenchmark().countFilteredManual() },
        "IntStream.countFiltered" to TaskWrapper{ IntStreamBenchmark().countFiltered() },
        "IntStream.countFilteredLocal" to TaskWrapper{ IntStreamBenchmark().countFilteredLocal() },
        "IntStream.reduce" to TaskWrapper { IntStreamBenchmark().reduce() },
        "Lambda.noncapturingLambdaNoInline" to TaskWrapper{ LambdaBenchmark().noncapturingLambdaNoInline() },
        "Lambda.capturingLambdaNoInline" to TaskWrapper{ LambdaBenchmark().capturingLambdaNoInline() },
        "Lambda.mutatingLambda" to TaskWrapper{ LambdaBenchmark().mutatingLambda() },
        "Lambda.mutatingLambdaNoInline" to TaskWrapper{ LambdaBenchmark().mutatingLambdaNoInline() },
        "Lambda.methodReferenceNoInline" to TaskWrapper{ LambdaBenchmark().methodReferenceNoInline() },
        "Life" to TaskWrapper { LifeBenchmark().bench() },
//        "LifeWithMarkHelpers" to TaskWrapper { LifeWithMarkHelpersBenchmark().bench() },
        "Loop.arrayIndexLoop" to TaskWrapper{ LoopBenchmark().arrayIndexLoop() },
        "Loop.arrayListLoop" to TaskWrapper{ LoopBenchmark().arrayListLoop() },
        "ParameterNotNull.invokeOneArgWithNullCheck" to TaskWrapper{ ParameterNotNullAssertionBenchmark().invokeOneArgWithNullCheck() },
        "ParameterNotNull.invokeOneArgWithoutNullCheck" to TaskWrapper{ ParameterNotNullAssertionBenchmark().invokeOneArgWithoutNullCheck() },
        "ParameterNotNull.invokeTwoArgsWithNullCheck" to TaskWrapper{ ParameterNotNullAssertionBenchmark().invokeTwoArgsWithNullCheck() },
        "ParameterNotNull.invokeTwoArgsWithoutNullCheck" to TaskWrapper{ ParameterNotNullAssertionBenchmark().invokeTwoArgsWithoutNullCheck() },
        "ParameterNotNull.invokeEightArgsWithNullCheck" to TaskWrapper{ ParameterNotNullAssertionBenchmark().invokeEightArgsWithNullCheck() },
        "ParameterNotNull.invokeEightArgsWithoutNullCheck" to TaskWrapper{ ParameterNotNullAssertionBenchmark().invokeEightArgsWithoutNullCheck() },
        "String.stringConcatNullable" to TaskWrapper{ StringBenchmark().stringConcatNullable() },
        "SubList.concatenate" to TaskWrapper{ SubListBenchmark().concatenate() },
        "SubList.concatenateManual" to TaskWrapper{ SubListBenchmark().concatenateManual() },
        "SubList.filterAndCount" to TaskWrapper{ SubListBenchmark().filterAndCount() },
        "SubList.filterAndCountWithLambda" to TaskWrapper{ SubListBenchmark().filterAndCountWithLambda() },
        "SubList.countWithLambda" to TaskWrapper{ SubListBenchmark().countWithLambda() },
        "SubList.filterManual" to TaskWrapper{ SubListBenchmark().filterManual() },
        "SubList.countFilteredManual" to TaskWrapper{ SubListBenchmark().countFilteredManual() },
        "SubList.countFiltered" to TaskWrapper{ SubListBenchmark().countFiltered() },
        "SubList.reduce" to TaskWrapper { SubListBenchmark().reduce() },
        "Switch.testSparseIntSwitch" to TaskWrapper{ SwitchBenchmark().testSparseIntSwitch() },
        "Switch.testDenseIntSwitch" to TaskWrapper{ SwitchBenchmark().testDenseIntSwitch() },
        "Switch.testConstSwitch" to TaskWrapper{ SwitchBenchmark().testConstSwitch() },
        "Switch.testObjConstSwitch" to TaskWrapper{ SwitchBenchmark().testObjConstSwitch() },
        "Switch.testVarSwitch" to TaskWrapper{ SwitchBenchmark().testVarSwitch() },
        "Switch.testDenseEnumsSwitch" to TaskWrapper{ SwitchBenchmark().testDenseEnumsSwitch() },
        "WithIndicies.withIndiciesManual" to TaskWrapper{ WithIndiciesBenchmark().withIndiciesManual() },
        "Calls.openMethodBimorphic" to TaskWrapper{ CallsBenchmark().classOpenMethodCall_BimorphicCallsite() },
        "Calls.openMethodTrimorphic" to TaskWrapper{ CallsBenchmark().classOpenMethodCall_TrimorphicCallsite() },
        "Calls.interfaceMethodBimorphic" to TaskWrapper{ CallsBenchmark().interfaceMethodCall_BimorphicCallsite() },
        "Calls.interfaceMethodTrimorphic" to TaskWrapper{ CallsBenchmark().interfaceMethodCall_TrimorphicCallsite() },
        "Calls.interfaceMethodHexamorphic" to TaskWrapper{ CallsBenchmark().interfaceMethodCall_HexamorphicCallsite() },
        "LocalObjects.localArray" to TaskWrapper{ LocalObjectsBenchmark().localArray() },
        "ComplexArrays.outerProduct" to TaskWrapper{ ComplexArraysBenchmark().outerProduct() },
    )


    fun runBenchmark() {
        kLog("[Case] ---------------start runBenchmark------------")
        val set = extendedBenchmarksSet + tasks
        val singleTaskCount = 50
        for (entry in set) {
            val key = entry.key
            val taskWrapper = entry.value
            var duration = 0f
            for (i in 0 until singleTaskCount) {
                duration += measureTime {
                    taskWrapper.task()
                }.inWholeMicroseconds.toFloat()
            }
            val time = duration / 1000
            kLog("[Case] $key 重复${singleTaskCount}次 总耗时:${time}ms 平均耗时:${ time/singleTaskCount }ms")
        }
        kLog("[Case] ---------------end runBenchmark------------")
    }
}

fun mainEntry() {
    Launcher.runBenchmark()
}

